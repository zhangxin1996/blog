React的开发模式是使用jsx，所以对应代码都是`编写的类似于js的一种语法`（一个函数中可以返回div标签，将HTML标签和JavaScript代码融合到一起了），之后通过 Babel 将 jsx 编译成 React.createElement 函数调用；

Vue也支持jsx的开发模式（之后会讲到），但大多数情况下，使用基于HTML的模板语法。在模板语法中，允许开发者以声明式编程的方式将 `DOM` 和`底层组件实例的数据`绑定到一起。在底层是实现中，Vue将模板编译成虚拟DOM渲染函数，这个后续讲到。

所以，对于学习Vue来说，学习模板语法是非常重要的。在学习模板语法之前先来了解下VSCode的代码片段。

## VSCode 代码片段

在前面练习Vue的过程中，有些代码片段需要经常写的，我们可以在VSCode中生成代码一个片段，方便之后快速生成。

VSCode中的代码片段有一定的固定格式，一般我们会借助一个在线工具来完成。

具体步骤如下：
1. 复制自己需要生成代码片段的代码；

``` html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="app"></div>

  <template id="my-app">
    <h2>{{message}}</h2>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          message: "Hello World"
        }
      }
    };

    Vue.createApp(App).mount("#app");
  </script>
</body>
</html>
```

2. [snippet generator](https://snippet-generator.app/)点击该网址，并生成代码片段；

``` 
"create vue3 app": {
  "prefix": "vue3app",
  "body": [
    "<!DOCTYPE html>",
    "<html lang=\"en\">",
    "<head>",
    "  <meta charset=\"UTF-8\">",
    "  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">",
    "  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">",
    "  <title>Document</title>",
    "</head>",
    "<body>",
    "  <div id=\"app\"></div>",
    "",
    "  <template id=\"my-app\">",
    "    <h2>{{message}}</h2>",
    "  </template>",
    "",
    "  <script src=\"../js/vue3.js\"></script>",
    "  <script>",
    "    const App = {",
    "      template: \"#my-app\",",
    "      data() {",
    "        return {",
    "          message: \"Hello World\"",
    "        }",
    "      }",
    "    };",
    "",
    "    Vue.createApp(App).mount(\"#app\");",
    "  </script>",
    "</body>",
    "</html>"
  ],
  "description": "create vue3 app"
}
```

3. 在VSCode中配置代码片段，文件 → 首选项 → 用户片段 → 搜索html.json；

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/01_VSCode代码片段步骤.png')" alt="VSCode代码片段步骤">


## Mustache语法（双大括号语法）

如果我们想把数据显示到模板（template）中，使用最多的语法是 Mustache语法（双大括号语法）的文本插值。

而且data函数返回的对象是有添加到`Vue的响应式系统`中，当`data中的属性发生改变`时，`对应的内容也会发生更新`。

当然，Mustache不仅仅可以是data中的属性，也可以是一个`JavaScript的表达式`。

代码如下：
``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <div>
      <!-- 1. Mustache语法的基本使用 -->
      <h2>{{ message }} - {{ message }}</h2>

      <!-- 2. 也可以是一个表达式 -->
      <h2>{{ counter * 10 }}</h2>
      <h2>{{ message.split(" ").reverse().join(" ") }}</h2>

      <!-- 3. 也可以是一个函数 -->
      <h2>{{ getReverseMessage1() }}</h2>
      <h2>{{ getReverseMesssage2 }}</h2>

      <!-- 4. 也可以是三元运算符 -->
      <h2>{{ isShow ? "哈哈哈" : "" }}</h2>
      <button @click="toggle">切换</button>


      <!-- 错误用法 -->
      <!-- 1. 赋值语句 -->
      <!-- <h2>{{ var name = 'abc' }}</h2> -->
      <!-- 2. 判断语句 -->
      <!-- <h2>{{ if(isShow) { return "哈哈哈" } }}</h2> -->
    </div>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          message: "Hello Vue3",
          counter: 100,
          isShow: true
        }
      },
      computed: {
        getReverseMesssage2() {
          return this.message.split(" ").reverse().join(" ");
        }
      },
      methods: {
        getReverseMessage1() {
          return this.message.split(" ").reverse().join(" ");
        },
        toggle() {
          this.isShow = !this.isShow;
        }
      }
    };

    Vue.createApp(App).mount("#app");
  </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/02_mustache语法练习.png')" alt="mustache语法练习">

::: danger 注意
以下方式是错误的：
``` html
<h2>{{ var name = "abc" }}</h2>
<h2>{{ if(isShow) {return "哈哈哈"} }}</h2>
```
Mustache中不可以是`赋值语句、if判断语句`。
:::


## v-once

v-once用于指定的元素或者组件只渲染一次，**是不需要表达式的**。当数据发生变化时，元素/组件以及其所有的子元素将视为静态内容并且跳过。该指令可以用于优化更新性能。

一个元素不添加v-once，一个元素添加v-once，代码如下：

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <h2>{{counter}}</h2>
    <div v-once>
      <h2>{{counter}}</h2>
      <h2>{{message}}</h2>
    </div>

    <button @click="increment">+1</button>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          counter: 100,
          message: "你好啊"
        }
      },
      methods: {
        increment() {
          this.counter++;
        }
      }
    };

    Vue.createApp(App).mount("#app");
  </script>
</body>
```

结果：当点击+1按钮时，不添加v-once指令的元素的counter会加1，添加v-once指令的子元素的counter不会加1。

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/03_v-once练习.png')" alt="v-once练习">

## v-text

用于更新元素的`textContent`，类型是：String。

代码如下：

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <h2 v-text="message"></h2>
    <!-- 等同于 -->
    <h2>{{message}}</h2>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          message: "Hello Vue3"
        }
      }
    };

    Vue.createApp(App).mount("#app");
  </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/04_v-text练习.png')" alt="v-text练习">

::: danger 注意
如果要更新部分`textContent`，那么使用 Mustache插值。
:::

## v-html

默认情况下，如果我们展示的内容是HTML结构，那么Vue并不会对其进行特殊的解析。只有使用`v-html`指令来进行展示，才能将我们希望的内容被Vue解析出来。

代码如下：

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <div v-html="message"></div>

    <!-- 原样展示 -->
    <div v-text="message"></div>
    <div>{{message}}</div>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          message: '<span style="color: red; background-color: blue;">你好啊</span>'
        }
      }
    };

    Vue.createApp(App).mount("#app");
  </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/05_v-html练习.png')" alt="05_v-html练习">

## v-pre

跳过这个元素和它的子元素的编译过程，用来展示原始的 Mustache 标签。不需要表达式。

意思是：有些内容不需要Mastache解析出来就是用这个指令。跳过大量没有指令的节点会加快编译。

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <h2 v-pre>{{message}}</h2>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          message: "Hello Vue3"
        }
      }
    };

    Vue.createApp(App).mount("#app");
  </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/06_v-pre练习.png')" alt="v-pre练习">

## v-cloak

这个指令保持在元素上直到关联组件实例结束编译。和CSS规则如`[v-cloak] {display: none;}`一起使用，这个指令可以隐藏未编译的 Mustache 标签，直到组件实例准备完成。不需要表达式。

<!-- 意思是：template渲染到浏览器上，{{ message }}还没来得及解析，那浏览器展示的就是`{{message}}`，等`{{message}}`解析后，浏览器展示Hello Vue3。Vue为了防止这种现象的出现，使用v-cloak指令配合CSS样式。

原理是：在`{{message}}`还没被解析出来之前，在该元素上多出来v-cloak属性，当有这个属性时，配合CSS样式就隐藏元素，当`{{message}}`被解析出来了，该元素上就没有这个属性了，这个元素就展现出来了。 -->

在Vue解析之前，h2元素中有属性v-bloak，只要有这个属性的标签就隐藏起来。在Vue解析之后，Vue会发现div有这个属性v-bloak会自动删掉就没有这个属性了，所以就显示出来数据。

``` html
<head>
  <style>
    [v-cloak] {
      display: none;
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <template id="my-app">
    <h2 v-cloak>{{message}}</h2>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          message: "Hello Vue3"
        }
      }
    };

    Vue.createApp(App).mount("#app");
  </script>
</body>
```

## v-bind绑定属性

除了内容需要动态来决定外，某些属性也希望动态来绑定。例如：
* 动态绑定a标签的href属性;
* 动态绑定img标签的src属性;
* 动态绑定class属性;
* 动态绑定style属性;

绑定属性我们使用`v-bind`指令，下面是[官方文档](https://v3.cn.vuejs.org/api/directives.html#v-bind)的使用方法：
* 缩写：`:`
* 预期：`any (with argument) | Object (without argument)`
* 参数：`attrOrProp (optional)`
* 修饰符：`.camel - 将 kebab-case attribute 名转换为 camelCase。`
* 用法：`动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。`

### 绑定基本属性

动态绑定img的src属性和a元素的href属性，代码如下：

``` html
<body>
  <div id="app"></div>

  <!-- 
    注意：
      Vue2 template模板中只能有一个根元素
      Vue3 允许template模板中可以有多个根元素
  -->
  <template id="my-app">
    <!-- 1. v-bind的基本使用 -->
    <img v-bind:src="imgUrl" alt="">
    <a v-bind:href="link">百度一下</a>

    <!-- 2. v-bind提供语法糖，将v-bind省略为: -->
    <img :src="imgUrl" alt="">
    <a :href="link">百度一下</a>


    <!-- 错误写法：imgUrl回当字符串原样显示，不会解析 -->
    <img src="imgUrl" alt="">
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App ={
      template: "#my-app",
      data() {
        return {
          imgUrl: "https://avatars.githubusercontent.com/u/10335230?v=4",
          link: "https://www.baidu.com"
        }
      }
    };

    Vue.createApp(App).mount("#app");
  </script>
</body>
```

### 绑定class属性

1. 对象语法

我们可以传给:class（v-bind:class的语法糖写法）一个对象，以动态切换class。代码如下：

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <!-- 1. 对象语法：{class类名: Boolean} -->
    <!-- 当Boolean值为true时绑定class类名，当Boolean值为false时不会绑定class类名 -->
    <div :class="{active: isActive}">{{message}}</div>

    <!-- 2. 对象中有多个键值对 -->
    <div :class="{active: isActive, title: isTitle}">{{message}}</div>

    <!-- 3. 默认的class和动态的class结合 -->
    <div class="abc cba" :class="{active: isActive, title: isTitle}">{{message}}</div>

    <!-- 4. 将数据对象放到单独的属性中 -->
    <div :class="classObject">{{message}}</div>

    <!-- 5. 将返回的对象放到computed方法中 -->
    <div class="abc cba" :class="getClassObj">{{message}}</div>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          message: "你好啊，李银河",
          isActive: true,
          isTitle: false,
          classObject: { 
            active: true,
            'text-danger': false
          }
        }
      },
      computed: {
        getClassObj() {
          return {active: this.isActive, title: this.isTitle};
        }
      }
    };

    Vue.createApp(App).mount("#app");
  </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/07_v-bind绑定class属性对象语法.png')" alt="v-bind绑定class属性对象语法">

2. 数组语法

我们可以给:class传递一个数组，以应用一个class列表。代码如下：

``` html
<body>
  <div id="app"></div>
  
  <template id="my-cpn">
    <!-- 1. 直接传入一个数组 -->
    <div :class="['abc', title]">{{message}}</div>

    <!-- 2. 在数组中可以使用三元运算符 -->
    <div :class="['abc', title, isActive ? 'active' : '']">{{message}}</div>

    <!-- 3. 数组中也可以使用对象语法 -->
    <div :class="['abc', title, {active: isActive}]">{{message}}</div>

    <!-- 注意：数组语法中，如果没有用引号的话会当做变量 -->
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-cpn",
      data() {
        return {
          message: "你好啊，李银河",
          title: "cba",
          isActive: true,
        }
      }
    };
    
    Vue.createApp(App).mount("#app");
  </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/08_v-bind绑定class属性数组语法.png')" alt="v-bind绑定class属性数组语法">

::: danger 注意
数组语法中，如果没有用引号的话会当做变量。
:::

### 绑定style属性

我们可以利用:style来绑定一些CSS内联样式。有些样式需要根据数据动态来决定。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名。

1. 对象语法

``` html
<body>
    <div id="app"></div>

    <template id="my-app">
      <!-- 1. font-szie属性可以直接写但要加单引号引起来，或者写成驼峰 -->
      <!-- :style="{cssPropertyName: cssPropertyValue}" -->
      <div :style="{color: 'red', 'font-size': '30px'}">哈哈哈</div>
      <div :style="{color: 'red', fontSize: '30px'}">哈哈哈</div>

      <!-- 2. 可以动态绑定属性值 -->
      <div :style="{color: 'red', fontSize: fimalFontSize + 'px'}">呵呵呵</div>

      <!-- 3. 将样式对象绑定到单独属性 -->
      <div :style="fimalStyleObj">呵呵呵</div>

      <!-- 4. 计算属性中返回对象 -->
      <div :style="getStyleObj">嗯嗯嗯</div>

    </template>

    <script src="../js/vue3.js"></script>
    <script>
      const App = {
        template: "#my-app",
        data() {
          return {
            fimalFontSize: 50,
            fimalStyleObj: {
              color: "red",
              "font-size": "50px",
              "font-weight": "bold"
            }
          }
        },
        computed: {
          getStyleObj() {
            return {color: 'red', fontSize: '30px'};
          }
        }
      };
      
      Vue.createApp(App).mount("#app");
    </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/09_v-bind绑定style属性对象语法.png')" alt="v-bind绑定style属性对象语法">


2. 数组语法

``` html
<body>
    <div id="app"></div>

    <template id="my-app">
      <!-- 将多个对象的属性进行合并 -->
      <div :style="[styleObj1, styleObj2]">哈哈哈</div>
    </template>

    <script src="../js/vue3.js"></script>
    <script>
      const App = {
        template: "#my-app",
        data() {
          return {
            styleObj1: {
              color: "red",
              fontSize: "30px"
            },
            styleObj2: {
              textDecoration: "underline"
            },
          }
        }
      };

      Vue.createApp(App).mount("#app");
    </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/10_v-bind绑定style属性数组语法.png')" alt="v-bind绑定style属性数组语法">


### 动态绑定属性名称

某些情况下，我们**属性名称**可能也不是固定的。前面无论绑定src、href、class、style其属性名称都是固定的，如果属性名称不是固定的，我们可以使用`:[属性名称]=属性值`的格式来定义，这种绑定方式就称为**动态绑定属性名称**。

``` html
<body>
    <div id="app"></div>

    <template id="my-app">
      <div :[title]="name">哈哈哈</div>
    </template>

    <script src="../js/vue3.js"></script>
    <script>
      const App = {
        template: "#my-app",
        data() {
          return {
            title: "cba",
            name: "kobe"
          }
        }
      };
      
      Vue.createApp(App).mount("#app");
    </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/11_v-bind动态绑定属性名称.png')" alt="v-bind动态绑定属性名称">


### 绑定一个对象-作为元素的属性

如果希望将一个对象中所有属性绑定到元素上的所有属性，非常简单，可以直接`v-bind="对象"`。这样对象的键值对会绑定到元素上。

``` html
<body>
    <div id="app"></div>

    <template id="my-app">
      <div v-bind="info">哈哈哈</div>
    </template>

    <script src="../js/vue3.js"></script>
    <script>
      const App = {
        template: "#my-app",
        data() {
          return {
            info: {
              name: "coderz",
              age: 18,
              height: 1.88
            }
          }
        }
      };
      
      Vue.createApp(App).mount("#app");
    </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/12_v-bind绑定一个对象.png')" alt="v-bind绑定一个对象">


## v-on绑定事件

在开发中，我们需要和用户进行各种各样的交互，监听用户发生的事件例如：**点击、拖拽、键盘事件**。

使用`v-on`指令监听事件，下面是[官方文档](https://v3.cn.vuejs.org/api/directives.html#v-on)的用法：

* 缩写：`@`
* 预期：`Function | Inline Statement（内联表达式） | Object`
* 参数：`event`
* 修饰符：
  * .stop - 调用 event.stopPropagation()。
  * .prevent - 调用 event.preventDefault()。
  * .capture - 添加事件侦听器时使用 capture 模式。
  * .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。
  * .{keyAlias} - 仅当事件是从特定键触发时才触发回调。
  * .once - 只触发一次回调。
  * .left - 只当点击鼠标左键时触发。
  * .right - 只当点击鼠标右键时触发。
  * .middle - 只当点击鼠标中键时触发。
  * .passive - { passive: true } 模式添加侦听器
* 用法：绑定事件监听器。

### v-on的基本使用

``` html
<head>
<style>
    .area {
      width: 200px;
      height: 200px;
      background-color: #ff0000;
    }
  </style>
</head>
<body>
    <div id="app"></div>

    <template id="my-app">
      <!-- 1. 基本使用 -->
      <!-- 完整写法：v-on:监听的事件="methods中的方法" -->
      <button v-on:click="btnClick">按钮</button>
      <div class="area" v-on:mousemove="mouseMove"></div>

      <!-- 2. 语法糖写法 -->
      <button @click="btnClick">按钮</button>
      <div class="area" @mousemove="mouseMove"></div>

      <!-- 3. 绑定一个表达式（只限简单的表达式，复杂的表达式写到方法中） -->
      <button @click="counter++">{{counter}}</button>

      <!-- 4. 绑定一个对象（对象中可以有多个监听事件） -->
      <div class="area" v-on="{click: btnClick, mousemove: mouseMove}"></div>
    </template>

    <script src="../js/vue3.js"></script>
    <script>
      const App = {
        template: "#my-app",
        data() {
          return {
            counter: 100
          }
        },
        methods: {
          btnClick() {
            console.log("按钮发生点击");
          },
          mouseMove() {
            console.log("鼠标移动");
          }
        }
      };
      
      Vue.createApp(App).mount("#app");
    </script>
</body>
```

### 参数传递

当通过methods中定义方法，以提供@click调用时，需要注意参数问题：

* 情况一：监听事件调用的方法没有参数

事件监听的时候且监听的方法不需要传递参数，只有满足这两个条件，调用方法后的小括号加不加的结果都是一样的。

``` html
<body>
  <div id="app">
    <button @click="btnClick1">按钮1</button>
    <button @click="btnClick1()">按钮1</button>
  </div>

  <script src="../js/vue.js"></script>
  <script>
    const app = new Vue({
      el: "#app",
      methods: {
        btnClick1() {
          console.log("-----btnClick1点击了");
        }
      }
    })
  </script>
</body>
```

结果为：

``` js
// "-----btnClick1点击了"
// "-----btnClick1点击了"
```

* 情况二：监听事件调用的方法有参数

如果调用方法时省略了小括号，但方法本身是需要传递参数的，这时Vue默认将浏览器生成的`Event事件对象`作为参数传递到方法。

如果调用方法时没有省略小括号，但小括号中没有传递参数，这时会将`undefined`作为参数传递到方法。

如果小括号中有参数传递，这时会将接收到的实参传递到方法。

``` html
<body>
  <div id="app">
    <!-- 事件调用的方法需要传递参数 -->
    <!-- 1. 省略小括号 -->
    <button @click="btnClick2">按钮2</button>
    <!-- 2. 没有传递参数 -->
    <button @click="btnClick2()">按钮2</button>
    <!-- 3. 传递参数 -->
    <button @click="btnClick2('abc)">按钮2</button>
  </div>

  <script src="../js/vue.js"></script>
  <script>
    const app = new Vue({
      el: "#app",
      methods: {
        btnClick2(abc) {
          console.log("-----btnClick2点击了", abc);
        }
      }
    })
  </script>
</body>
```

结果为：

``` js
"-----btnClick2点击了", Event事件对象
"-----btnClick2点击了", undefined
"-----btnClick2点击了", abc
```

* 情况三：监听事件调用的方法传递多个参数

当需要传递多个参数同时需要传递Event事件对象时，可在调用方法的小括号中通过`$event`传递Event事件对象。

``` html
<body>
  <div id="app">
    <!-- 事件调用的方法需要传递多个参数 -->
    <!-- 1. 省略小括号 -->
    <button @click="btnClick3">按钮3</button>
    <!-- 2. 省略参数 -->
    <button @click="btnClick3()">按钮3</button>
    <!-- 3. 传递参数 -->
    <button @click="btnClick3($event, 'abc')">按钮3</button>
  </div>

  <script src="../js/vue.js"></script>
  <script>
    const app = new Vue({
      el: "#app",
      methods: {
        btnClick3(event, abc) {
          console.log("+++++btnClick3点击了", event, abc);
        }
      }
    })
  </script>
</body>
```

结果为：

``` js
// "+++++btnClick3点击了", Event事件对象, undefined
// "+++++btnClick3点击了", undefined, undefined
// "+++++btnClick3点击了", Event事件对象, abc
```

### v-on修饰符

修饰符相当于对事件进行一些特殊处理，这里讲解了click事件的.stop（阻止冒泡）修饰符和keyup事件的.enter（键盘回车）修饰符。

``` html
<body>
    <div id="app"></div>

    <template id="my-app">
      <!-- 阻止冒泡事件添加修饰符 .stop -->
      <div class="content" @click="divClick">
        <button @click.stop="btnClick">按钮</button>
      </div>

      <!-- 键盘弹起事件与enter修饰符 -->
      <input type="text" @keyup.enter="handleKeyup">
    </template>

    <script src="../js/vue3.js"></script>
    <script>
      const App = {
        template: "#my-app",
        methods: {
          divClick() {
            console.log("div发生了点击");
          },
          btnClick() {
            console.log("button发生了点击");
          },
          handleKeyup(event) {
            console.log("keyup");
            console.log(event.target.value);
          }
        }
      };
      
      Vue.createApp(App).mount("#app");
    </script>
</body>
```

了解更多请看这里：[v-on事件修饰符](https://zhangxin1996.github.io/pages/frontend/frame/vue/05_v-on%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC.html#v-on%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6)和[v-on按键修饰符](https://zhangxin1996.github.io/pages/frontend/frame/vue/05_v-on%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC.html#v-on%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6)。


## 条件渲染

在一些情况下，我们需要根据当前条件决定某些元素或组件是否渲染，这时就需要使用条件判断。

Vue提供了以下指令来进行条件判断：
* v-if
* v-else-if
* v-else
* v-show

### 条件渲染的基本使用

点击按钮切换isShow，当isShow的值为true时才会渲染内容。

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <h2 v-if="isShow">{{message}}</h2>
    <button @click="btnClick">切换</button>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          message: "Hello Vue3",
          isShow: true
        }
      },
      methods: {
        btnClick() {
          this.isShow = !this.isShow;
        }
      }
    };
    
    Vue.createApp(App).mount("#app");
  </script>
</body>
```

### 多个条件判断的渲染

通过在input输入框中输入分数，动态展示对应分数的评分信息。

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <input type="text" v-model="score">

    <h2 v-if="score >= 90">优秀</h2>
    <h2 v-else-if="score >= 80">良好</h2>
    <h2 v-else-if="score >= 60">及格</h2>
    <h2 v-else>不及格</h2>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          score: "",
        }
      }
    };
    
    Vue.createApp(App).mount("#app");
  </script>
</body>
```


结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/13_多个条件判断渲染.png')" alt="多个条件判断渲染">

::: tip 提示
`v-if`的渲染原理：
1. v-if是惰性的只有当条件为true时，才会真正渲染元素；
2. 当条件为false时，其判断的元素完全不会被渲染或者被销毁不会存在DOM中；
:::

### template元素和v-if结合

因为v-if指令必须添加到一个元素上，当切换多个元素时必须在外层有一个根元素来包裹，如果是div元素的话会多渲染一个DOM节点，而template元素最终不会被渲染出来。

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <template v-if="isShowHa">
      <h2>哈哈哈</h2>
      <h2>哈哈哈</h2>
      <h2>哈哈哈</h2>
    </template>
    <template v-else>
      <h2>呵呵呵</h2>
      <h2>呵呵呵</h2>
      <h2>呵呵呵</h2>
    </template>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          isShowHa: true
        }
      }
    };
    
    Vue.createApp(App).mount("#app");
  </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/14_template元素和v-if结合使用.png')" alt="template元素和v-if结合使用">

### v-show的条件渲染

根据表达式的真假值，切换元素的CSS属性`display`。当条件变化时该指令触发过渡效果。

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <!-- 不显示时会添加行内样式 display: none; -->
    <h2 v-show="isShow">{{message}}</h2>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          message: "Hello Vue3",
          isShow: true
        }
      }
    };
    
    Vue.createApp(App).mount("#app");
  </script>
</body>
```
结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/15_条件判断v-show.png')" alt="条件判断v-show">

### v-if和v-show的不同

1. 用法上：
v-show不支持template元素，也不能和v-else结合使用；

2. 本质上：
使用v-show指令的元素无论是否到浏览器上，它的DOM元素实际都是有渲染的，只是通过CSS的display属性来进行切换；
使用v-if指令的元素，当条件为false时压根就不会渲染到DOM中；

3. 开发时如何选选择：
如果在显示和隐藏之间频繁的切换，使用v-show指令；
如果不会频繁的发生切换，使用v-if指令；

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <h2 v-if="isShow">{{message}}</h2>
    <h2 v-show="isShow">{{message}}</h2>

    <button @click="btnClick">切换</button>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          message: "Hello Vue3",
          isShow: true
        }
      },
      methods: {
        btnClick() {
          this.isShow = !this.isShow;
        }
      }
    };
    
    Vue.createApp(App).mount("#app");
  </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/16_v-if和v-show的区别.png')" alt="v-if和v-show的区别">

## 列表渲染

在真实开发中，往往在服务器拿到一些数据并对其渲染，这时使用`v-for`指令来完成一组数据的遍历。

### 遍历数组

我们可以使用`v-for`指令基于一个数组来渲染一个列表。`v-for`指令需要使用`item in items`形式的特殊语法。其中items是源数据数组，item是被迭代的数组元素的**别名**。

如果我们需要索引值，可以使用格式`(item, index) in items`。

::: danger 注意
数组元素项item是在前面，索引值项index是在后面的。
:::

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <h2>遍历数组</h2>
    <ul>
      <li v-for="(item, index) in movies">{{item}}-{{index}}</li>
    </ul>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          movies: ["流浪地球", "少年派", "速度与激情", "红海行动"]
        }
      }
    };
    
    Vue.createApp(App).mount("#app");
  </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/17_列表渲染-遍历数组.png')" alt="列表渲染-遍历数组">

### 遍历对象

你也可以用`v-for`指令遍历对象。并支持一、二、三个参数。
* 一个参数：`value in object`，键值value；
* 两个参数：`(value, key) in object`，键值value和键名key；
* 三个参数：`(value, key, index) in object`，键值value和键名key和索引值；

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <h2>遍历对象</h2>
    <ul>
      <li v-for="(value, key, index) in info">{{key}}: {{value}} - {{index}}</li>
    </ul>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          info: {
            name: "coderz",
            age: 18,
            height: 1.88
          }
        }
      }
    };
    
    Vue.createApp(App).mount("#app");
  </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/18_列表渲染-遍历对象.png')" alt="列表渲染-遍历对象">

### 遍历数字

`v-for`指令也接受整数遍历。

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <h2>遍历数字</h2>
    <ul>
      <li v-for="(num, index) in 10">{{num}}-{{index}}</li>
    </ul>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {}
      }
    };
    
    Vue.createApp(App).mount("#app");
  </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/19_列表渲染-遍历数字.png')" alt="列表渲染-遍历数字">

### 在template元素中使用v-for

也可以利用带有`v-for`的`template`元素来循环渲染包含多个元素的内容。

``` html
<head>
<style>
    ul {
      list-style: none;
    }

    .line {
      width: 500px;
      margin: 10px 0 10px 0; 
      border-bottom: 1px solid #000;
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <template id="my-app">
    <ul>
      <template v-for="(value, key) in info">
        <li>{{value}}</li>
        <li>{{key}}</li>
        <li class="line"></li>
      </template>
    </ul>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          info: {
            name: "coderz",
            age: 18,
            height: 1.88
          }
        }
      }
    };
    
    Vue.createApp(App).mount("#app");
  </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/20_列表渲染-template和v-for结合使用.png')" alt="列表渲染-template和v-for结合使用">

### 数组更新检测

1. 变更方法

Vue将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：
* push()
* pop()
* shift()
* unshift()
* splice()
* sort()
* reverse()

2. 替换数组

上面的方法会直接替换原数组，但是某些方法不会替换原来的数组，而是会生成新的数组。当使用非变更方法时，可用新数组替换旧数组。
* filter()
* slice()
* concat()

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <ul>
      <li v-for="item in movies">{{item}}</li>

      <input type="text" v-model="newMovie">
      <button @click="addClick">添加</button>
    </ul>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          movies: ["流浪地球", "少年派", "速度与激情", "红海行动"],
          newMovie: ""
        }
      },
      methods: {
        addClick() {
          this.movies.push(this.newMovie);
          this.newMovie = "";
        }
      }
    };
    
    Vue.createApp(App).mount("#app");
  </script>
</body>
```

### v-for中的key是什么作用

在使用v-for进行列表渲染时，通常会给元素或者组件绑定一个`key属性`。

key属性的作用官方解释：
* key属性主要用在Vue的`虚拟DOM的diff算法`，在`新旧nodes`对比时辨识`VNodes`；
* 如果不使用key，Vue会使用一种算法来最小化元素的移动并且尽可能尝试就地修改/复用相同类型元素；
* 而使用key时，它会基于key的顺序变化重新排列元素，并且key不再存在的元素将始终被移除/销毁；

官方的解释不太好理解，比如以下几个问题：
* 什么是新旧nodes，什么是VNodes？
* 不使用key时，怎么最小化的修改和复用元素？
* 使用key时，怎么基于key的顺序重新排列元素？

#### 认识VNode

因为目前我们还没有比较完整的学习组件的概念，所以我们先理解HTML元素创建出来的VNode。

VNode（Virtual Node）意思是虚拟节点，事实上无论是组件还是元素，它们最终在Vue中表示出来的都是一个个的VNode。

VNodes的本质是一个JavaScript对象，例如：template中一个div标签怎么通过Vue解析为VNode：

``` html
<!-- div元素 -->
<div class="title" style="font-size: 12px; color: red">你好啊</div>

<!-- VNode -->
const vnode = {
  tag: "div",
  props: {
    class: "title",
    style: {
      "font-size": "12px",
      "color": "red"
    }
  },
  children: "你好啊"
};
```

生成VNode的作用：
1. 做跨平台 ；
2. diff算法的时候性能会高一些；

#### 虚拟DOM

如果我们不是简单的div，而是有一大堆的元素，那么它们应该会形成一个`VNodes Tree`，也叫虚拟DOM（Virtual DOM）。

``` vue
<template>
  <div>
    <p>
      <i>哈哈哈哈</i>
      <i>哈哈哈哈</i>
    </p>
    <span>嘻嘻嘻嘻</span>
    <strong>呵呵呵呵</strong>
  </div>
</template>
```

先有template生成一大堆VNode（虚拟节点）之后形成树，这个树就是VDOM（虚拟DOM），VDOM再进行渲染在浏览器上看到的真实DOM。


#### 插入f元素案例

我们实现一个案例，点击按钮插入f元素：

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <ul>
      <li v-for="item in letters">{{item}}</li>
    </ul>

    <button @click="insert">插入f元素</button>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          letters: ['a', 'b', 'c', 'd']
        }
      },
      methods: {
        insert() {
          this.letters.splice(2, 0, "f");
        }
      }
    };

    Vue.createApp(App).mount("#app");
  </script>
</body>
```

在插入f元素时，ul和button是不需要更新的，只有li列表是需要更新的。对于列表中a、b、c、d是没有变化的，在操作真实的DOM时只需插入f的li元素即可。

那么在Vue中对于列表的更新是如何操作的呢？首先会判断元素上有没key属性，对于有key和没key会调用两个不同的方法：
* 有key，调用`patchKeyedChildren`方法；
* 没有key，调用`patchUnKeyedChildren`方法；

源码：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/21_Vue源码对于列表渲染key的判断.png')" alt="Vue源码对于列表渲染key的判断">

#### 没有key的操作

源码：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/22_Vue源码没有key的操作图一.png')" alt="Vue源码没有key的操作图一">
<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/23_Vue源码没有key的操作图二.png')" alt="Vue源码没有key的操作图二">

操作过程如下：

从上面源码发现diff算法的效率并不高，c和d来说并不需要任何的改动，但是因为c被d所使用的，导致后续所有内容都要依次进行改动，并最后新增d元素。

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/24_没有key属性的情况.png')" alt="没有key属性的情况">


#### 有key的操作

* 第一步：从头部开始进行遍历、比较

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/25_有key属性的情况第一步.png')" alt="有key属性的情况第一步">
<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/25_有key属性的情况第一步图解.png')" alt="有key属性的情况第一步图解">

* 第二步：从尾部开始进行遍历、比较

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/26_有key属性的情况第二步.png')" alt="有key属性的情况第二步">
<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/26_有key属性的情况第二步图解.png')" alt="有key属性的情况第二步图解">

* 第三步：如果旧节点遍历完，但依然有新节点，就挂载新的节点

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/27_有key属性的情况第三步.png')" alt="有key属性的情况第三步">
<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/27_有key属性的情况第三步图解.png')" alt="有key属性的情况第三步图解">

* 第四步：如果新节点遍历完，但依然有旧节点，就卸载旧的节点

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/28_有key属性的情况第四步.png')" alt="有key属性的情况第四步">
<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/28_有key属性的情况第四步图解.png')" alt="有key属性的情况第四步图解">

* 第五步：未知节点序列，最大程度移动节点，有多余的旧节点就卸载，有新增的新节点就挂载

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/29_有key属性的情况第五步.png')" alt="有key属性的情况第五步">
<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/29_有key属性的情况第五步图解.png')" alt="有key属性的情况第五步图解">

所以，有key时Vue进行diff算法的时候，会尽量利用key进行优化操作。在进行插入还是重置排序的时候，保持相同的key可以让diff算法更加高效。


## 表单输入绑定

### v-model的基本使用

**表单提交**是开发中非常常见的功能，也是和用户交互的重要手段。例如：用户在登录、注册时需要提交账号密码或者用户在检索、创建、更新信息时，需要提交一些数据。这些都需要我们在**代码逻辑中获取用户提交的数据**，通常我们使用`v--model指令`来完成。

`v-model指令`在表单&lt;input&gt;、&lt;textarea&gt;及&lt;select&gt;元素上创建双向数据绑定。它会根据**控件类型**自动选取正确的方式来更新元素。尽管有些神奇，但**v-model本质上不过是语法糖**。它**负责监听用户的输入事件来更新数据**，并在某些极端场景下进行一些特殊处理。

代码如下：
``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <input type="text" v-model="message">

    <h2>{{message}}</h2>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          message: "Hello World"
        }
      }
    };

    Vue.createApp(App).mount("#app");
  </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/30_v-model的基本使用.png')" alt="v-model的基本使用">

### v-model的实现原理

官方又说到，**v-model的原理**包括背后两个操作：
* 给input的value属性通过v-bind绑定属性值数据message；
* 给input通过v-on绑定input事件监听到函数中，函数会获取到最新的value值赋值到数据message；

``` html
<input type="text" v-model="message">

<!-- 等价于 -->

<input type="text" :value="message" @input="message = $event.target.value">
```

### v-model绑定textarea

我们来看一下v-model绑定`textarea`，代码如下：

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <!-- 1. textarea -->
    <label for="intro">
      <div>自我介绍：</div>
      <textarea id="intro" v-model="intro" cols="30" rows="10"></textarea>
    </label>
    <h2>intro当前的值是：{{intro}}</h2>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          intro: "Hello World"
        }
      }
    };

    Vue.createApp(App).mount("#app");
  </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/31_v-model绑定textarea.png')" alt="v-model绑定textarea">


### v-model绑定checkbox

我们来看一下绑定`checkbox`，分为单个复选框和多个复选框：

1. 单个复选框

当为单个复选框时，v-model绑定到布尔值，此时input的value并不影响v-model的值，代码如下：

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <!-- 2.1 单个checkbox -->
    <label for="agree">
      <input type="checkbox" id="agree" v-model="isAgree">同意协议
    </label>
    <h2>isAgree当前的值是：{{isAgree}}</h2>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          isAgree: true
        }
      }
    };

    Vue.createApp(App).mount("#app");
  </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/33_v-model绑定checkbox-单个复选框.png')" alt="v-model绑定checkbox-单个复选框">

2. 多个复选框

当为多个复选框时，因为可以选中多个，所以v-model绑定到同一个数组。当选中某一个复选框时，就会将对应input的value值添加到数组中。代码如下：

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <!-- 2.2 多个checkbox -->
    <label for="basketball">
      <input type="checkbox" id="basketball" v-model="hobbies" value="basketball">篮球
    </label>
    <label for="football">
      <input type="checkbox" id="football" v-model="hobbies" value="football">足球
    </label>
    <label for="tennis">
      <input type="checkbox" id="tennis" v-model="hobbies" value="tennis">网球
    </label>
    <h2>hobbies当前的值是：{{hobbies}}</h2>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          hobbies: []
        }
      }
    };

    Vue.createApp(App).mount("#app");
  </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/34_v-model绑定checkbox-多个复选框.png')" alt="v-model绑定checkbox-多个复选框">

### v-model绑定radio

我们来看一下v-model绑定radio，用于选择其中的一项，代码如下：

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <!-- 3. radio -->
    <label for="male">
      <input type="radio" id="male" v-model="gender" value="male">男
    </label>
    <label for="female">
      <input type="radio" id="female" v-model="gender" value="female">女
    </label>
    <h2>gender当前的值是：{{gender}}</h2>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          gender: "male"
        }
      }
    };

    Vue.createApp(App).mount("#app");
  </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/35_v-model绑定radio.png')" alt="v-model绑定radio">

### v-model绑定select

和checkbox一样，slect也分单选和多选两种情况。

1. 单选

因为只能选中一个值，所以v-model绑定的是一个值，当选中某一个option时，会将它对应的value值赋值到fruit。代码如下：

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <!-- 4.1 单选 -->
    <select name="" id="" v-model="fruit">
      <option disabled value="">请选择您喜欢的水果</option>
      <option value="apple">苹果</option>
      <option value="banana">香蕉</option>
      <option value="orange">橙子</option>
    </select>
    <h2>fruit当前的值是：{{fruit}}</h2>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          fruit: ""
        }
      }
    };

    Vue.createApp(App).mount("#app");
  </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/36_v-model绑定select-单选.png')" alt="v-model绑定select-单选">

2. 多选

因为可以选中多个值，所以v-model绑定的是一个数组，当选中多个option时，会将选中的option对应的value值添加到数组fruits，代码如下：

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <!-- 4.2 多选 -->
    <select name="" id="" v-model="fruits" multiple size="2">
      <option value="apple">苹果</option>
      <option value="banana">香蕉</option>
      <option value="orange">橙子</option>
    </select>
    <h2>fruits当前的值是：{{fruits}}</h2>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          fruits: []
        }
      }
    };

    Vue.createApp(App).mount("#app");
  </script>
</body>
```

结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/02_vue3-template-syntax/37_v-model绑定select-多选.png')" alt="v-model绑定select-多选">


### v-model的值绑定

在前面的案例中**大部分值都是在template中固定好的**，例如：hobbies的三个输入框的值basketball、football、tennis。但在真实开发中，我们的**数据可能来自于服务器**，先从服务器**将数据请取下来**之后**绑定到data返回的对象**中，再通过**v-bind**将值绑定，这个过程就是**值绑定**。

下面我们以select为案例，代码如下：

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <select v-model="fruit">
      <option disabled value="">请选择您喜欢的水果</option>
      <option v-for="item in fruits" :value="item.value">{{item.text}}</option>
    </select>
    <h2>fruit当前的值是：{{fruit}}</h2>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          fruits: [
            {value: "apple", text: "苹果"},
            {value: "banner", text: "香蕉"},
            {value: "orange", text: "橘子"}
          ],
          fruit: ""
        }
      }
    };

    Vue.createApp(App).mount("#app");
  </script>
</body>
```

### v-model修饰符-lazy修饰符

默认情况下，v-model在双向绑定时绑定的是**input事件**，那么在input中每次内容输入后就会触发将输入框最新的值和绑定的属性进行同步。

如果我们在v-model后跟lazy修饰符，会将绑定的事件切换为**change事件**，只有当提交时（比如按回车）才会同步。

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <!-- 1. lazy修饰符 -->
    <input type="text" v-model.lazy="message">
    <h2>{{message}}</h2>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          message: "Hello World"
        }
      }

    Vue.createApp(App).mount("#app");
  </script>
</body>
```

### v-model修饰符-number修饰符

如果想自动将用户输入的内容转为Number类型，可以给 v-model 后添加 number 修饰符。

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <!-- 2. number修饰符  -->
    <input type="number" v-model.number="score">
    <button @click="getScoreTypeof">检测score类型</button>
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          score: 90
        }
      },
      methods: {
        getScoreTypeof() {
          console.log(this.score, typeof this.score);
        }
      }
    };

    Vue.createApp(App).mount("#app");
  </script>
</body>
```

::: danger 注意
即使在 `type="number"` 时，HTML 输入元素的值也总会返回字符串。
:::

### v-model修饰符-trim修饰符

如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符。

``` html
<body>
  <div id="app"></div>

  <template id="my-app">
    <!-- 3. trim修饰符 -->
    <input type="text" v-model.trim="message" @change="getMessage">
  </template>

  <script src="../js/vue3.js"></script>
  <script>
    const App = {
      template: "#my-app",
      data() {
        return {
          message: "Hello World",
        }
      },
      methods: {
        getMessage() {
          console.log(this.message);
        }
      }
    };

    Vue.createApp(App).mount("#app");
  </script>
</body>
```

### v-mode组件上使用

v-model也可以使用在组件上，Vue2版本和Vue3版本有一些区别。具体的使用方法，后面讲组件化开发再具体学习。