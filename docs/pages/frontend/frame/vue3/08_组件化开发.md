## 组件的嵌套及拆分

之前只创建了一个App.vue的组件，如果一个应用程序将所有的逻辑都放在这一个组件中，那么这组件就会变得非常的臃肿及难以维护。所以组件化的核心思想是要对组件进行拆分，拆分成一个个小的组件，小的组件又有自己对应的逻辑，之后将这些小的组件进行组合嵌套到一起，最终形成我们的应用程序。

例如我们App原来的逻辑代码：

``` vue
<!-- App.vue -->
<template>
  <div>
    <div class="header">
      <h2>Header</h2>
      <h2>NavBar</h2>
    </div>
    <div class="main">
      <h2>Banner</h2>
      <ul>
        <li>商品列表1</li>
        <li>商品列表2</li>
        <li>商品列表3</li>
        <li>商品列表4</li>
        <li>商品列表5</li>
      </ul>
    </div>
    <div class="footer">
      <h2>Footer</h2>
      <h2>免责申明</h2>
    </div>
  </div>
</template>

<script>
  export default {
    
  }
</script>

<style scoped>

</style>
```

我们可以按照如下方式进行拆分，每一块逻辑只需要去对应的组件中编写即可。

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/01_组件的拆分.png')" alt="组件的拆分">

::: tip 补充
在使用VSCode开发vue时，本身是不支持.vue后缀名的，也就是没有高亮及代码提示，这里推荐几个VSCode插件：Vetur、Vue VSCode Snippets(代码片段)，之后就可以通过`vbase-css`来生成基本的.vue文件结构了。
:::

::: tip 提示1
VSCode插件Vetur中有默认配置 `Auto Import`，意思是直接使用组件会自动添加import导入组件和在components中注册组件。看起来比较好用，但不建议使用。有两点：
* 如果不使用格式化插件的话，放的比较乱甚至是错的；
* 希望对导入的组件有一个顺序；
:::

::: tip 提示2
因为当前项目是基于Vue CLI，而Vue CLI又基于Webpack，虽然说webpack中默认配置了.vue文件后缀名（extensions）,但不写的话会有两个问题，建议手动添加文件后缀名：
* 注册完组件使用时没有提示；
* 当 `ctrl键+鼠标左键` 点击组件时，不会跳转到对应的组件里面；
:::

``` vue
<!-- App.vue -->
<template>
  <div>
    <Header></Header>
    <Main></Main>
    <Footer></Footer>
  </div>
</template>

<script>
  import Header from "./Header.vue";
  import Main from "./Main.vue";
  import Footer from "./Footer.vue";

  export default {
    components: {
      Header,
      Main,
      Footer
    }
  }
</script>

<style scoped>

</style>
```

``` vue
<!-- Header.vue -->
<template>
  <div class="header">
    <h2>Header</h2>
    <h2>NavBar</h2>
  </div>
</template>

<script>
  export default {
    
  }
</script>

<style scoped>

</style>
```

``` vue
<!-- Main.vue -->
<template>
  <div class="main">
    <h2>Banner</h2>
    <ul>
      <li>商品列表1</li>
      <li>商品列表2</li>
      <li>商品列表3</li>
      <li>商品列表4</li>
      <li>商品列表5</li>
    </ul>
  </div>
</template>

<script>
  export default {
    
  }
</script>

<style scoped>

</style>
```

``` vue
<!-- Footer.vue -->
<template>
  <div class="footer">
    <h2>Footer</h2>
    <h2>免责申明</h2>
  </div>
</template>

<script>
  export default {
    
  }
</script>

<style scoped>

</style>
```

## 组件的CSS作用域

我们在编写.vue文件时，style标签有scoped属性，添加scoped的作用是：防止组件之间的样式相互污染，具体实现是给标签添加属性`data-v-十六进制的数字`。

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/02_vue文件的style标签的scoped属性.png')" alt="vue文件的style标签的scoped属性">

在Vue3中，组件中&lt;template&gt;可以有多个根节点，当App组件和和其子组件HelloWorld都没有唯一的根组件，就会引起父组件中定义的样式在子组件也可能会生效。

``` vue
<!-- App.vue -->
<template>
  <h2>App</h2>
  <hello-world></hello-world>
</template>

<script>
  import HelloWorld from "./HelloWorld.vue";

  export default {
    components: {
      HelloWorld
    }
  }
</script>

<style scoped>
  h2 {
    color: #ff0000;
  }
</style>
```

``` vue
<!-- HelloWorld.vue -->
<template>
  <h2>Hello World</h2>
</template>

<script>
  export default {
    
  }
</script>

<style scoped>

</style>
```

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/03_组件的CSS作用域出现问题.png')" alt="组件的CSS作用域出现问题">

产生此结果的原因是：在父组件App中定义了h2样式，当是h2标签并且有`data-v-十六进制的数字`属性样式才生效，本来此属性是在子组件HelloWorld根元素的，但子组件HelloWorld没有唯一的根元素，HelloWorld组件的h2标签和父组件的h2标签同层级，也拥有`data-v-十六进制的数字`属性，所以就会引起父组件中定义的样式在子组件也可能会生效。

避免上面问题出现的解决方案是：**组件有唯一的根元素且不要直接给标签设置样式，最好给标签设置class属性来设置样式**。


## 组件的通信

在上面的组件嵌套逻辑中，存在如下关系：App组件是Header、Main、Footer组件的父组件，对应的Header、Main、Footer组件是App组件的子组件。

在开发过程中，经常遇到需要组件之间相互进行通信：
* 父组件一下请求下所有的数据，但数据是需要传递给子组件来展示，这时就需要**父组件向子组件传递数据**；
* 子组件中发生了事件，需要由父组件来完成某些操作，这时就需要**子组件向父组件传递事件**；

那么父子组件之间的通信方式是怎么来实现的呢？
* 父组件传递子组件：通过props属性；
* 子组件传递父组件：通过$emit触发事件；

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/04_父子组件之间的通信方式.png')" alt="父子组件之间的通信方式">

### 父组件传递给子组件

在开发中常见的就是父子组件之间的通信，比如父组件有一些数据需要子组件来进行展示，这时就需要通过props来完成组件之间的通信。

那什么是props？props是你可以在组件上注册的一些自定义的attribute，父组件给这些attribute赋值，子组件通过attribute的名称获取到对应的值。

那props有两种常见的用法：
* 方式一：字符串数组，在数组中的字符串就是attribute的名称；
* 方式二：对象类型，可以在指定attribute的名称同时，指定它需要传递的类型、是否必需传递和默认值等等信息；

#### props的数组用法

在父组件中有三种传递数据方式，如下：

``` vue
<!-- 父组件App.vue -->
<template>
  <div>
    <!-- 1. 直接传递固定的值 -->
    <show-message title="哈哈哈" content="我是哈哈哈哈"></show-message>

    <!-- 2. 数据定义在data函数返回的对象中，动态来传递 -->
    <show-message :title="title" :content="content"></show-message>

    <!-- 3. 将数据定义在一个对象中，之后动态传递 -->
    <show-message :title="message.title" :content="message.content"></show-message>
    <show-message v-bind="message"></show-message>
  </div>
</template>

<script>
  import ShowMessage from "./ShowMessage.vue";

  export default {
    components: {
      ShowMessage
    },
    data() {
      return {
        title: "嘻嘻嘻",
        content: "我是嘻嘻嘻嘻",
        message: {
          title: "呵呵呵",
          content: "我是呵呵呵呵"
        }
      }
    }
  }
</script>

<style scoped>

</style>
```

``` vue
<!-- 子组件ShowMessage.vue -->
<template>
  <div>
    <h2>{{title}}</h2>
    <p>{{content}}</p>
  </div>
</template>

<script>
  export default {
    props: ["title", "content"]
  }
</script>

<style scoped>

</style>
```

#### props的对象用法

数组用法只能传入attribute的名称，并不能对其进行任何形式的限制。如果使用对象的用法就可以让props变得更加完善了，可以对传入的内容做更多的限制了：
* 指定attribute的类型；
* 指定attribute是否必须传递；
* 指定当attribute没有传递时，attribute的默认值；

虽然可以像如下方式进行书写：

``` vue
<!-- 子组件ShowMessage.vue -->
<script>
  export default {
    props: {
      title: String,
      content: String
    }
  }
</script>
```

但不推荐这种写法，我们可以写的更加复杂一些，指定类型、必传、默认值：

``` vue
<!-- 子组件ShowMessage.vue -->
<script>
  export default {
    props: {
      title: {
        type: String,
        required: true
      },
      content: {
        type: String,
        default: "我是呜呜呜呜"
      }
    }
  }
</script>
```

::: tip 提示
attribute是否必须传递和默认值只需指定一个即可。
:::

细节补充一：type的类型都可以是哪些呢，如下：
* String
* Number
* Boolean
* Array
* Object
* Date
* Function
* Symbol

细节补充二：对象类型的其他写法做出展示：

``` vue
<script>
  export default {
    // 1. 基础的类型检测（null 和 undefined 会通过任何类型检测）
    propA: String,
    propB: Number,
    // 2. 多个可能的类型
    propC: [String, Number],
    // 3. 必填的字符串
    propD: {
      type: String,
      require: true
    },
    // 4. 带有默认值的数字
    propE: {
      type: Number,
      default: 100
    },
    // 5. 带有默认值的对象
    propF: {
      type: Object,
      default: function() {
        // 对象或者数组的默认值必须从一个工厂函数获取
        return { message: "hello" }
      }
    },
    // 6. 自定义验证函数
    propG: {
      validator(value) {
        // 这个值必须匹配下列字符串的一个，返回true通过验证，返回false报错
        return ["success", "warning", "danger"].includes(value);
      }
    },
    // 7. 具有默认值的函数
    propH: {
      type: Function,
      default: function() {
        // 与对象或数组的默认值不同，这不是一个工厂函数，这是一个用作一个默认值的函数
        return "Default function"
      }
    }
  }
</script>
```

::: tip 补充
为什么attribute的type为Object(或者Array)类型时，默认值是工厂函数返回的对象(或者数组)？

因为子组件可能在父组件中多次使用创建多个组件实例，如果在父组件中没有传递attribute时，默认值引用的是同一个对象，当其中一个组件实例做出如下修改`props.info="kobe"`，其他的组件实例也会跟着一块修改的，为了避免这种情况的发生，通过工厂函数返回对象的这种做法，可以让引用类型 props 要相互隔离。

这样做真的可以吗？是的，当子组件多次使用时创建组件实例都会重新执行default函数，每次default函数都会返回新的对象（或者数组），当修改props属性中内容的时候，只会修改自己的。
:::

细节补充三：prop的大小写命名问题，

在HTML中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解析为小写字符。这意味着当你使用DOM模板进行传值时，camelCase（驼峰命名法）的prop名需要使用其等价的 kebab-case（短横线分割命名）的写法。

``` vue
<!-- 父组件App.vue -->
<template>
  <div>
    <show-message :message-info="messageInfo"></show-message>
  </div>
</template>

<script>
  export default {
    data() {
      return {
        messageInfo: "你好啊，李银河！"
      }
    }
  }
</script>
```

``` vue
<!-- 子组件ShowMessage.vue -->
<template>
  <div>
    <p>{{messageInfo}}</p>
  </div>
</template>

<script>
  export default {
    props: {
      messageInfo: {
        type: String
      }
    }
  }
</script>
```

#### 非Prop的Attribute传递

何为非prop的Attribute？当给一个组件传递某些属性但该属性并没有在组件中定义对应的props或者emits时，我们就称之为**非prop的Attribute**。常见的属性是：id属性、class属性、style属性、name属性等等。

对非prop的attribute的处理有三种情况：
1. 组件有单个根节点的attribute
当组件有单个根节点时，非prop的attribute将自动添加到组件根节点的attribute中去：

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/05_非prop的attribute之组件有单个根节点的处理.png')" alt="非prop的attribute之组件有单个根节点的处理">

2. 禁止attribute继承
如果不希望组件的根元素继承attribute，可以在组件中设置`inheritAttrs: false`，

``` vue
<!-- 子组件 ShowMessage.vue -->
<template>
  <div>
    <h2>{{title}}</h2>
    <p>{{content}}</p>
    <p>{{messageInfo}}</p>
  </div>
</template>

<script>
  export default {
    inheritAttrs: false,
  }
</script>

<style scoped>

</style>
```

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/06_不希望组件的根元素继承attribute.png')" alt="不希望组件的根元素继承attribute">

禁用attribute继承的常见情况是：需要将attribute应用于唯一根组件之外的其他元素，我们可以通过`$attrs`来访问所有的非prop的attribute。

``` vue
<!-- 子组件 ShowMessage.vue -->
<template>
  <div>
    <h2 :class="$attrs.class">{{title}}</h2>
    <p>{{content}}</p>
    <p>{{messageInfo}}</p>
  </div>
</template>

<script>
  export default {
    inheritAttrs: false,
  }
</script>

<style scoped>

</style>
```

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/07_将attribute应用于其他元素.png')" alt="将attribute应用于其他元素">

::: tip 补充
如果有多个非prop的attribute需要绑定的话，可以通过`v-bind="$attrs"`的方式进行绑定。
:::

3. 组件有多个根节点的attribute

多个根节点的attribute如果没有显示的进行绑定，就会报如下警告：

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/08_多个根节点的attribute没有显示的进行绑定结果.png')" alt="多个根节点的attribute没有显示的进行绑定结果">

所以我们要手动的指定要绑定到哪一个元素上，

``` vue
<!-- 父组件App.vue -->
<template>
  <div>
    <mult-root-element id="aaa"></mult-root-element>
  </div>
</template>

<script>
  import MultRootElement from "./MultRootElement.vue"

  export default {
    components: {
      MultRootElement
    }
  }
</script>

<style scoped>

</style>
```

``` vue
<!-- 子组件MultRootElement -->
<template>
  <h2>MultRootElement</h2>
  <h2 :id="$attrs.id">MultRootElement</h2>
  <h2>MultRootElement</h2>
</template>

<script>
  export default {
    
  }
</script>

<style scoped>

</style>
```

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/09_组件有多个根节点的attribute.png')" alt="组件有多个根节点的attribute">


### 子组件传递给父组件

当子组件内发生一些事件时，比如在子组件中发生了点击，需要告诉父组件做出某些响应。则需要在子组件中通过自定义事件的方式传递给父组件，如果在传递的过程中，子组件还有一些内容也想要传递给父组件，这也是可以的。

上面的操作如何完成呢？

* 首先，在子组件中定义好在某些情况下触发的事件名称；
* 其次，在父组件中以v-on的方式传入要监听的事件名称，并且绑定到对应的方法中；
* 最后，在子组件中发生某个事件的是时候，根据事件名称触发对应的事件；

下面以经典计数器案例来实现子组件传递给父组件事件，在子组件内部是监听两个按钮的点击，点击之后通过`this.$emit`的方式将事件发送出去到父组件。

``` vue
<!-- 子组件CounterOperation.vue -->
<template>
  <div>
    <button @click="decrement">-1</button>
    <button @click="increment">+1</button>
  </div>
</template>

<script>
  export default {
    // 触发自定义事件前先要注册
    emits: ["sub", "add"],
    methods: {
      decrement() {
        // 触发事件
        this.$emit("sub");
      },
      increment() {
        // 触发事件
        this.$emit("add");
      }
    }
  }
</script>

<style scoped>

</style>
```

``` vue
<!-- 父组件App.vue -->
<template>
  <div>
    <h2>当前计数：{{counter}}</h2>
    <counter-operation @sub="subOne" @add="addOne"></counter-operation>
  </div>
</template>

<script>
  import CounterOperation from "./CounterOperation.vue";

  export default {
    components: {
      CounterOperation
    },
    data() {
      return {
        counter: 100
      }
    },
    methods: {
      subOne() {
        this.counter--;
      },
      addOne() {
        this.counter++;
      }
    }
  }
</script>

<style scoped>

</style>
```

::: tip 提示
Vue3与Vue2子组件传递事件给父组件的不同点，Vue3在子组件内触发自定义事件之前要先将自定义事件注册，通过`emits`属性。
:::

自定义事件也可以传递一些参数给父组件，参数可以是一个也可以是多个，

``` vue
<!-- 子组件CounterOperation.vue -->
<template>
  <div>
    <input type="text" v-model.number="num">
    <button @click="incrementN">+N</button>
  </div>
</template>

<script>
  export default {
    // 触发自定义事件前先要注册
    emits: ["addN"],
    data() {
      return {
        num: 0
      }
    },
    methods: {
      incrementN() {
        this.$emit("addN", this.num, "coderz", 18);
        this.num = 0;
      }
    }
  }
</script>

<style scoped>

</style>
```

``` vue
<!-- 父组件App.vue -->
<template>
  <div>
    <h2>当前计数：{{counter}}</h2>
    <counter-operation @addN="addNum"></counter-operation>
  </div>
</template>

<script>
  import CounterOperation from "./CounterOperation.vue";

  export default {
    components: {
      CounterOperation
    },
    data() {
      return {
        counter: 100
      }
    },
    methods: {
      addNum(num, name, age) {
        this.counter += num;
        console.log(name, age);
      }
    }
  }
</script>

<style scoped>

</style>
```

在点击按钮后，不仅counter加input框中的数字得到的结果，还会在控制台打印出name和age。

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/10_子组件传递事件给父组件并携带多个参数.png')" alt="子组件传递事件给父组件并携带多个参数">

上面`emits`属性的值是一个数组，当然也可以是一个对象，对象写法的主要目的：**对传入的参数进行验证**，

``` vue
<!-- 子组件CounterOperation.vue -->
<script>
  export default {
    emits: {
      sub: null,
      add: null,
      addN: function(num, name, age) {
        if(num > 10) {
          return true;
        }
        return false;
      }
    },
  }
</script>
```

当input框中输入5点击按钮，这样写依然可以传递给父组件的，不过控制台会警告验证是失败的，这样更容易定位到传递的参数是有问题的。


### 父子组件间通信综合案例

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/11_商品页面的切换案例.png')" alt="商品页面的切换案例">

实现步骤：
* App父组件传递titles数据给TabControl子组件进行展示；
* 在TabControl子组件中通过`v-for指令`遍历titles数据，当点击每个item时，动态添加active样式；
* TabControl子组件传递事件给App父组件，并携带参数index，App父组件根据传递的index动态切换下面的界面；

``` vue
<!-- 父组件App.vue -->
<template>
  <div>
    <tab-control :titles="titles" @titleClick="titleClick"></tab-control>
    <div>{{contents[currentIndex]}}</div>
  </div>
</template>

<script>
  import TabControl from "./TabControl.vue";

  export default {
    components: {
      TabControl
    },
    data() {
      return {
        titles: ["衣服", "鞋子", "裤子"],
        contents: ["衣服界面", "鞋子界面", "裤子界面"],
        currentIndex: 0
      }
    },
    methods: {
      titleClick(index) {
        this.currentIndex = index;
      }
    }
  }
</script>

<style scoped>
   
</style>
```

``` vue
<!-- 子组件TabControl.vue -->
<template>
  <div class="tab-control">
    <div class="tab-control-item" 
         :class="{active: currentIndex===index}" 
         v-for="(item, index) in titles" 
         :key="item"
         @click="itemClick(index)">
      <span>{{item}}</span>
    </div>
  </div>
</template>

<script>
  export default {
    emits: ["titleClick"],
    props: {
      titles: {
        type: Array,
        default: function() {
          return []
        }
      }
    },
    data() {
      return {
        currentIndex: 0
      }
    },
    methods: {
      itemClick(index) {
        if(index === this.currentIndex) return;
        this.currentIndex = index;
        this.$emit("titleClick", index);
      }
    }
  }
</script>

<style scoped>
  .tab-control {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 49px;
  }
  .tab-control-item {
    flex: 1;
    text-align: center;
    font-size: 16px;
  }
  .tab-control-item span {
    padding: 4px 8px; 
  }

  .tab-control-item.active {
    color: #ff0000;
  }
  .tab-control-item.active span {
    border-bottom: 3px solid #ff0000;
  }
</style>
```

### 非父子组件的通信

在开发中，在构建了组件树之后，除了父子组件之间的通信之外，还会有非父子组件之间的通信。这里我们主要讲两种方式：
* Provide/Inject；
* mitt全局事件总线；

#### provide/inject

provide和inject用于**非父子组件之间共享数据**。

比如通常有一些深度嵌套的组件，而深层的子组件想要获取父组件的部分内容，这种情况下，如果仍然将 prop 沿着组件链逐级传递下去，就会非常麻烦。

对于以上这种情况使用一对`provide`和`inject`，无论层级结构有多深，父组件都可以作为其所有子组件的依赖提供者。这个特性有两部分：父组件有一个`provide`选项来提供数据，子组件有一个`inject`选项来开始使用这些数据。

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/12_Provide和Inject使用结果示意图.png')" alt="Provide和Inject使用结果示意图">

当我们有这样的层次结构，想将App组件中的数据直接共享给HomeContent组件：

``` 
App.vue
└─ Home.vue
   ├─ HomeContent.vue
```

通过 provide（父组件提供数据）/inject（在子孙组件中注入数据） 方法，我们可以直接执行以下操作：

``` vue
<!-- 爷组件App.vue -->
<template>
  <div>
    <home></home>
  </div>
</template>

<script>
  import Home from "./Home.vue";

  export default {
    components: {
      Home
    },
    provide: {
      name: "coderz",
      age: 18
    }
  }
</script>

<style scoped>

</style>
```

``` vue
<!-- 孙组件HomeContent.vue -->
<template>
  <div>
    <h2>HomeContent</h2>
    <h2>{{name}}-{{age}}</h2>
  </div>
</template>

<script>
  export default {
    // 通过 inject 对数据进行注入再使用
    inject: ["name", "age"]
  }
</script>

<style scoped>

</style>
```

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/13_Provide和Inject的基本使用.png')" alt="Provide和Inject的基本使用">

但是如果 provide 中提供的数据来自组件实例的data，那么我们就想要通过this来获取，这时就会报错，

``` vue
<!-- 爷组件App.vue -->
<script>
  import Home from "./Home.vue";
  // console.log(this);

  export default {
    components: {
      Home
    },
    provide: {
      name: "coderz",
      age: 18,
      length: this.name.length
    },
    data() {
      return {
        name: ["abc", "cba", "bca"]
      }
    }
  }
</script>
```

``` vue
<!-- 孙组件HomeContent.vue -->
<template>
  <div>
    <h2>HomeContent</h2>
    <h2>{{name}}-{{age}}--{{length}}</h2>
  </div>
</template>

<script>
  export default {
    // 通过 inject 对数据进行注入再使用
    inject: ["name", "age", "length"]
  }
</script>

<style scoped>

</style>
```

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/14_Provide中数据来自data通过this获取报错.png')" alt="Provide中数据来自data通过this获取报错">

原因是this的指向并不是组件实例而是undefined，当this向上一级寻找作用域时最终到script标签，注意：对象并没有作用域。所以，我们需要将 provide 转换为返回对象的函数。修改如下：

``` vue
<!-- 爷组件App.vue -->
<script>
  import Home from "./Home.vue";
  // console.log(this);

  export default {
    components: {
      Home
    },
    provide() {
      return {
        name: "coderz",
        age: 18,
        length: this.names.length
      }
    },
    data() {
      return {
        names: ["abc", "cba", "bca"]
      }
    }
  }
</script>
```

结果展示：

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/15_将Provide转换为返回对象的函数的结果.png')" alt="将Provide转换为返回对象的函数的结果">

事实上，你可以将依赖注入看作是“long range props”，除了：
* 父组件不需要知道哪些子组件使用它 provide 的 property；
* 子组件不需要知道 inject 的 proerty 来自哪里；

::: tip 提示
只有当父组件需要共享一些简单的数据，可使用 provide和inject。一般将provide默认写成函数的形式。
:::

在上面的例子中，如果我们修改了`names`的列表，使用了 length 的子组件并不会是响应式的，子组件中是没有变化的。这是因为当我们修改了 names 列表之后，之前在 provide 中引入的 this.names.length 本身并不是响应式的。

那么怎么样可以让我们的数据变成响应式的？我们可以使用响应式的一些API来完成这些功能，比如**computed函数**。当然这个 computed 是Vue3的新特性，在之后会专门讲解，这里大家可以直接使用一下。

``` vue
<!-- 爷组件App.vue -->
<template>
  <div>
    <home></home>
    <button @click="btnClick">change names</button>
  </div>
</template>

<script>
  import Home from "./Home.vue";
  import { computed } from "vue";

  console.log(this);
  export default {
    components: {
      Home
    },
    provide() {
      return {
        name: "coderz",
        age: 18,
        length: computed(() => this.names.length)
      }
    },
    data() {
      return {
        names: ["abc", "cba", "bca"]
      }
    },
    methods: {
      btnClick() {
        this.names.push("coder");
        console.log(this.names);
      }
    }
  }
</script>

<style scoped>

</style>
```

``` vue
<!-- 孙组件HomeContent.vue -->
<template>
  <div>
    <h2>HomeContent</h2>
    <h2>{{name}}-{{age}}--{{length.value}}</h2>
  </div>
</template>

<script>
  export default {
    // 通过 inject 对数据进行注入再使用
    inject: ["name", "age", "length"]
  }
</script>

<style scoped>

</style>
```

结果展示：

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/16_Provide处理响应式数据.png')" alt="Provide处理响应式数据">

在这种情况下，任何对 names.length 的改变都会被正确地反映在注入 length 的组件中。


#### 全局事件总线mitt库

在vue2中通过创建vue实例来实现全局事件总线（eventBus）功能，但vue3从实例移除了$on、$off和$once方法，所以如果希望继续使用全局事件总线，就要通过第三方库，这里Vue3官方有推荐一些库，例如：mitt 或 tiny-emitter。这里我们主要学习mitt库的使用。

首先，先安装这个库：

``` sh
$ npm install --save mitt
```

其次，封装一个工具 `eventbus.js`：

``` js
import mitt from "mitt";

const emitter = mitt();

export default emitter;
```

接下来我们使用mitt事件总线工具，我们有这样的层次结构：

``` 
App.vue
└─ Home.vue
   ├─ HomeContent.vue
├─ About.vue
```

我们在 About.vue 中触发事件，在 HomeContent.vue 中监听事件。

``` vue
<!-- About.vue -->
<template>
  <div>
    <h2>About</h2>
    <button @click="btnClick">About按钮点击</button>
  </div>
</template>

<script>
  import emitter from "./utils/eventBus.js";

  export default {
    methods: {
      btnClick() {
        console.log("about组件中按钮发生了点击");
        emitter.emit("z", {name: "coderz", age: 18});
        emitter.emit("kobe", {name: "kobe", age: 40});
      }
    }
  }
</script>

<style scoped>

</style>
```

``` vue
<!-- HomeContent.vue -->
<template>
  <div>
    <h2>HomeContent</h2>
  </div>
</template>

<script>
  import emitter from "./utils/eventBus.js";

  export default {
    created() {
      // 监听一个事件
      emitter.on("z", function(info) {
        console.log("z event:", info);
      });
      emitter.on("kobe", function(info) {
        console.log("kobe event:", info);
      });

      // 监听所有事件
      emitter.on("*", function(type, info) {
        console.log("* event:", type, info);
      })
    }
  }
</script>

<style scoped>

</style>
```

结果展示：

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/17_使用mitt全局事件总线工具.png')" alt="使用mitt全局事件总线工具">

::: tip 提示
当HomeContent组件一旦创建完成就开始监听事件，所以要在created生命周期函数中监听。
:::

在组件销毁时，我们希望取消掉之前注册的函数监听，可以在destroyed生命周期函数中进行操作：

``` vue
<script>
  import emitter from "./utils/eventBus.js";

  export default {
    destroyed() {
      // 如果要取消掉 emitter 中所有的监听
      emitter.all.clear();

      // 如果只取消 emitter 中某一个监听，需要将其定位一个的函数，之后只需取消函数的引用即可
      function onFoo(info) {
        console.log("z event:", info);
      }

      emitter.on('foo', onFoo)   // 监听
      emitter.off('foo', onFoo)  // 取消监听
    }
  }
</script>
```


## 插槽

### 认识插槽slot

在开发中，我们会经常封装一个个可复用的组件，通过props传递一些数据给组件并在组件中展示。props只能传递数据并不能改变组件中的标签元素，但为了让组件具备更强的通用性，我们想使用组件时希望组件显示的是一个按钮或者一张图片，所以我们应该让使用者决定这一区域存放什么内容和标签元素。

比如：我们想定制一个通用性的导航组件——NavBar。

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/18_认识插槽.png')" alt="认识插槽">

以上都是导航栏组件，它们既有相同又有不同。相同点：组件都分成三个区域：左边-中间-右边，不同点：每块区域的内容都是不固定的。

这时就可以在NavBar中定义插槽（slot），而插槽其实就是：**抽取共性，预留不同**。也就是说，将共同的元素、内容依然在组件内进行封装，而会将不同的元素使用 slot 作为占位，让使用者来决定显示什么元素。

### 插槽的基本使用

vue中将&lt;slot&gt;元素作为承载分发内容的出口，在封装组件时，使用特殊的元素&lt;slot&gt;就可以为封装组件开启一个插槽，该插槽具体显示什么内容取决于父组件中的定义。

比如：有一个MySlotCpn组件，该组件内有一个插槽，当App组件在使用MySlotCpn组件时，我们**可以插入普通的文本、html元素或者组件元素**。在MySlotCpn组件开始标签和结束标签之间插入的内容就会被放入到插槽的位置。

``` vue
<!-- App.vue -->
<template>
  <div>
    <!-- 1. 普通的文本 -->
    <my-slot-cpn>
      Hello World
    </my-slot-cpn>

    <!-- 2. html元素 -->
    <my-slot-cpn>
      <button>我是普通按钮</button>
    </my-slot-cpn>

    <!-- 3. 组件元素 -->
    <my-slot-cpn>
      <my-button/>
    </my-slot-cpn>
  </div>
</template>

<script>
  import MySlotCpn from "./MySlotCpn.vue";
  import MyButton from "./MyButton.vue";

  export default {
    components: {
      MySlotCpn,
      MyButton
    }
  }
</script>

<style scoped>

</style>
```

``` vue
<!-- MySlotCpn.vue -->
<template>
  <div>
    <h2>MySlotCpn开始</h2>
    <slot></slot>
    <h2>MySlotCpn结束</h2>
  </div>
</template>

<script>
  export default {
    
  }
</script>

<style scoped>

</style>
```

``` vue
<!-- MyButton.vue -->
<template>
  <div>
    <button>自定义button</button>
  </div>
</template>

<script>
  export default {
    
  }
</script>

<style scoped>

</style>
```

显示结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/19_插槽的基本使用.png')" alt="插槽的基本使用">

### 插槽的默认内容

当使用插槽时，如果没有插入对应的内容，那么需要显示一个默认的内容。当然，这个默认的内容只会在没有提供插入的内容时，才会显示。

``` vue
<!-- App.vue -->
<template>
  <div>
    <my-slot-cpn></my-slot-cpn>
  </div>
</template>

<script>
  import MySlotCpn from "./MySlotCpn.vue";

  export default {
    components: {
      MySlotCpn
    }
  }
</script>

<style scoped>

</style>
```

``` vue
<!-- MySlotCpn.vue -->
<template>
  <div>
    <h2>MySlotCpn开始</h2>
    <slot>
      <h2>我是默认显示的内容</h2>
    </slot>
    <h2>MySlotCpn结束</h2>
  </div>
</template>

<script>
  export default {
    
  }
</script>

<style scoped>

</style>
```

显示结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/20_插槽的默认内容.png')" alt="插槽的默认内容">

### 具名插槽 

#### 具名插槽的使用

如果一个组件中含有**多个插槽**，在使用该组件时，开始标签和结束标签插入了多个内容，我们会发现默认情况下每个插槽都会获取到我们插入的内容进行显示。

``` vue
<!-- App.vue -->
<template>
  <div>
    <nav-bar>
      <button>左边按钮</button>
      <h2>中间标题</h2>
      <i>右边i元素</i>
    </nav-bar>
  </div>
</template>

<script>
  import NavBar from "./NavBar.vue";

  export default {
    components: {
      NavBar
    }
  }
</script>

<style scoped>

</style>
```

``` vue
<!-- NavBar.vue -->
<template>
  <div class="nav-bar">
    <div class="left">
      <slot></slot>
    </div>
    <div class="center">
      <slot></slot>
    </div>
    <div class="right">
      <slot></slot>
    </div>
  </div>
</template>

<script>
  export default {
    
  }
</script>

<style scoped>
  .nav-bar {
    display: flex;
  }
  .nav-bar .left, .right {
    width: 100px;
    background: red;
  }
  .nav-bar .center {
    flex: 1;
    background: blue;
    text-align: center;
  }
</style>
```

显示结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/21_组件有多个插槽并使用组件插入多个内容时的效果.png')" alt="组件有多个插槽并使用组件插入多个内容时的效果">

其实我们是想让内容对应插槽显示，这时我们就可以使用**具名插槽**。具名插槽就是给插槽起个名字，&lt;slot&gt; 元素有一个特殊的 attribute：`name`。这个 attribute 可以用来定义额外的插槽：

``` vue
<!-- NavBar.vue -->
<template>
  <div class="nav-bar">
    <div class="left">
      <slot name="left"></slot>
    </div>
    <div class="center">
      <slot name="center"></slot>
    </div>
    <div class="right">
      <slot name="right"></slot>
    </div>
  </div>
</template>
```

在向具名插槽提供内容的时候，我们可以在一个&lt;template&gt;元素上使用 `v-slot` 指令，并以 `v-slot` 的参数的形式提供其名称：

``` vue
<!-- App.vue -->
<template>
  <div>
    <nav-bar>
      <template v-slot:left>
        <button>左边按钮</button>
      </template>
      <template v-slot:center>
        <h2>中间标题</h2>
      </template>
      <template v-slot:right>
        <i>右边i元素</i>
      </template>
    </nav-bar>
  </div>
</template>
```

现在 &lt;template&gt; 元素中的所有内容都将会被传入相应的插槽。其显示结果：

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/22_具名插槽效果.png')" alt="具名插槽效果">

::: tip 提示
一个不带 name 的 &lt;slot&gt; 出口会带有隐含的名字“default”。

::: vue
<template>
  <div>
    <slot></slot>
    <!-- 相当于 -->
    <slot name="default"></slot>
  </div>
</template>
:::
:::

#### 动态插槽名

在使用 `v-slot` 指令时，插槽的名称都是固定的，比如：v-slot:left或者v-slot:center等等。其实可以通过`v-slot:[dynamicSlotName]`方式动态绑定一个名称。

有个案例：可让使用者通过配置来决定具名插槽的名字。

``` vue
<!-- App.vue -->
<template>
  <div>
    <nav-bar :name="name">
      <template v-slot:left>
        <button>左边按钮</button>
      </template>
      <template v-slot:center>
        <h2>中间标题</h2>
      </template>
      <template v-slot:right>
        <i>右边i元素</i>
      </template>
      <template v-slot:[name]>
        <i>why内容</i>
      </template>
    </nav-bar>
  </div>
</template>

<script>
  import NavBar from "./NavBar.vue";

  export default {
    components: {
      NavBar
    },
    data() {
      return {
        name: "why"
      }
    }
  }
</script>
```

``` vue
<!-- NavBar.vue -->
<template>
  <div class="nav-bar">
    <div class="left">
      <slot name="left"></slot>
    </div>
    <div class="center">
      <slot name="center"></slot>
    </div>
    <div class="right">
      <slot name="right"></slot>
    </div>
    <div class="addition">
      <slot :name="name"></slot>
    </div>
  </div>
</template>

<script>
  export default {
    props: {
      name: {
        type: String
      }
    }
  }
</script>

<style scoped>
  .nav-bar {
    display: flex;
  }
  .nav-bar .left, .right, .addition {
    width: 100px;
    background: red;
  }
  .nav-bar .center {
    flex: 1;
    background: blue;
    text-align: center;
  }
</style>
```

#### 具名插槽使用时缩写

在使用具名插槽时，`v-slot指令`也和`v-bind指令`、`v-on指令`一样也有缩写，即把参数之前的所有内容（v-slot:）替换成字符串#。例如：将 v-slot:left 替换为 #left。

``` vue
<!-- App.vue -->
<template>
  <div>
    <nav-bar>
      <template #left>
        <button>左边按钮</button>
      </template>
      <template #center>
        <h2>中间标题</h2>
      </template>
      <template #right>
        <i>右边i元素</i>
      </template>
    </nav-bar>
  </div>
</template>
```

### 渲染作用域

在App组件的一个插槽，想要访问ChildCpn组件中的数据时，将不起作用。原因是：它们是跨组件访问的。

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/23_渲染作用域.png')" alt="渲染作用域">

请记住这条规则：

> 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子级作用域中编译的；

### 作用域插槽

有时希望插槽可以访问到子组件中的内容是非常必要的，例如：当一个组件被用来渲染一个项目数组时，我们使用插槽并且希望可以自定义项目的渲染方式。

可通过以下步骤来实现：
1. 在App组件中定义好数据；
2. 通过props传递数据给ShowNames组件；
3. 在ShowNames组件中通过v-for遍历names属性；
4. 将传递给父组件App的数据通过给&lt;slot&gt;元素定义插槽的prop；
5. 在父级作用域中，通过v-slot:default来获取到&lt;slot&gt;元素的props；
6. 使用slotProps中的item和index属性；

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/24_作用域插槽.png')" alt="作用域插槽">

#### 独占默认插槽的缩写语法

如果我们的插槽是默认插槽default的话，那么在使用时`v-slot:default="slotProps"`可以简写为`v-slot="slotProps`。

``` vue
<!-- App.vue -->
<template>
  <div>
    <show-names :names="names">
      <template v-slot="slotProps">
        <button>{{slotProps.item}} - {{slotProps.index}}</button>
      </template>
    </show-names>
  </div>
</template>
```

并且我们的插槽只有默认插槽时，组件的开始标签可以被插槽的模板来使用，这样就可以直接把`v-slot="slotProps"`写在组件的开始标签。

``` vue
<!-- App.vue -->
<template>
  <div>
    <show-names :names="names" v-slot:default="slotProps">
      <button>{{slotProps.item}} - {{slotProps.index}}</button>
    </show-names>
  </div>
</template>
```

#### 默认插槽和具名插槽一起使用

当即有默认插槽又有具名插槽时，或者出现多个插槽时，请始终为所有的插槽使用完整的基于&lt;template&gt;的语法：

``` vue
<!-- App.vue -->
<template>
  <div>
    <show-names :names="names">
      <template v-slot:default="slotProps">
        <button>{{slotProps.item}} - {{slotProps.index}}</button>
      </template>
      <template v-slot:why>
        <i>我是why插槽的内容</i>
      </template>
    </show-names>
  </div>
</template>
```

``` vue
<!-- ShowNames.vue -->
<template>
  <div>
    <template v-for="(item, index) in names" :key="item">
      <slot :item="item" :index="index"></slot>

      <slot name="why"></slot>
    </template>
  </div>
</template>
```

## 动态组件

### 动态组件基本使用
我们想要实现一个功能，点击tab-bar，切换显示不同的组件，如下图：

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/25_动态组件的基本使用.png')" alt="动态组件的基本使用">

实现这个案例有三种不同的方案：
* 方案一：通过if判断，切换不同组件；
* 方案二：通过动态组件的方式；
* 方案三：路由的方式（之后会讲到）；

先来展示第一种方案：通过if判断来显示不同组件。

``` vue
<template>
  <div>
    <template v-for="(tab, index) in tabs" :key="tab">
        <button :class="{active: currentTab === tab}" @click="tabClick(tab)">{{tab}}</button>
    </template>

    <!-- 方案一：通过v-if进行判断，切换不同组件 -->
    <template v-if="currentTab === 'home'">
      <home></home>
    </template>
    <template v-else-if="currentTab === 'about'">
      <about></about>
    </template>
    <template v-else>
      <category></category>
    </template>
  </div>
</template>

<script>
  import Home from "./pages/Home.vue";
  import About from "./pages/About.vue";
  import Category from "./pages/Category.vue";

  export default {
    components: {
      Home,
      About,
      Category
    },
    data() {
      return {
        tabs: ["home", "about", "category"],
        currentTab: "home"
      }
    },
    methods: {
      tabClick(tab) {
        this.currentTab = tab;
      }
    }
  }
</script>

<style scoped>
  .active {
    color: #ff0000;
  }
</style>
```

下面是动态组件的展示方案：

动态组件是使用**component组件**，通过**特殊的 attribute is来实现**。那么is属性的值可以是：
* 通过 component 函数注册的全局组件；
* 通过在组件对象的 components 对象中注册的局部组件；

``` vue
<template>
  <div>
    <template v-for="(tab, index) in tabs" :key="tab">
        <button :class="{active: currentTab === tab}" @click="tabClick(tab)">{{tab}}</button>
    </template>

    <!-- 方案二：动态组件方式 -->
    <component :is="currentTab"></component>
  </div>
</template>

<script>
  import Home from "./pages/Home.vue";
  import About from "./pages/About.vue";
  import Category from "./pages/Category.vue";

  export default {
    components: {
      Home,
      About,
      Category
    },
    data() {
      return {
        tabs: ["home", "about", "category"],
        currentTab: "home"
      }
    },
    methods: {
      tabClick(tab) {
        this.currentTab = tab;
      }
    }
  }
</script>

<style scoped>
  .active {
    color: #ff0000;
  }
</style>
```

### 动态组件传递数据和事件监听

当然也可以给动态组件传递数据和监听事件，只不过是将**需要的属性和监听事件**都放到 component 组件上使用。

name 和 age 属性会传递给每一个子组件，只需在对应的组件获取对应的数据即可。在子组件内部可以发射事件到父组件并且可以携带参数，在Home组件的根元素div上定义点击事件，点击事件中发射事件父组件会监听事件。

``` vue
<!-- App.vue -->
<template>
  <div>
    <template v-for="(tab, index) in tabs" :key="tab">
        <button :class="{active: currentTab === tab}" @click="tabClick(tab)">{{tab}}</button>
    </template>

    <component :is="currentTab" 
                name="why" 
                :age="18" 
                @pageClick="pageClick">
    </component>
  </div>
</template>

<script>
  export default {
    methods: {
      pageClick() {
        console.log("page 内部发生了点击");
      }
    }
  }
</script>
```

``` vue
<!-- Home.vue -->
<template>
  <div class="home" @click="divClick">
    <h2>Home组件：{{name}} - {{age}}</h2>
  </div>
</template>

<script>
  export default {
    props: {
      name: {
        type: String,
        default: ""
      },
      age: {
        type: Number,
        default: 0
      }
    },
    emits: ['pageClick'],
    methods: {
      divClick() {
        this.$emit("pageClick");
      }
    }
  }
</script>

<style scoped>

</style>
```


## 认识keep-alive

前面是对Home组件进行了改造，现在对About组件进行改造，在About组件中实现计数器案例，例如将About组件中counter增加到10后切换到Home组件再切回到About组件，发现counter的状态不会保留下来，依然是0。

造成此结果的原因是：默认情况下，切换组件会销毁About组件，等到再次切换回来之后会重新创建About组件。所以之前的状态也就不会保留。但在开发中需要继续保持组件的状态，而不要销毁，这时可以使用内置组件：keep-alive。

``` vue
<!-- App.vue -->
<template>
  <div>
    <keep-alive>
      <component :is="currentTab" 
                 name="why" 
                 :age="18" 
                 @pageClick="pageClick">
      </component>
    </keep-alive>
  </div>
</template>
```

像上面一样书写后，About组件就不会销毁，counter的状态也依然可以保留。

当然，keep-alive也有一些属性：
* include：String | RegExp | Array，只有名称匹配的组件会被缓存；
* exclude: String | RegExp | Array，任何名称匹配的组件都不会被缓存；
* max: Number | String，最多可以缓存的组件实例，一旦达到这个数值，再有缓存的组件会从之前的缓存组件中把最近没有访问的组件实例销毁；

``` vue
<!-- App.vue -->

<template>
  <div>
    <!-- String类型：逗号分割字符串 -->
    <keep-alive include="home,about">
      <component :is="view"></component>
    </keep-alive>

    <!-- RegExp类型（使用`v-bind`） -->
    <keep-alive :include="/home|about/">
      <component :is="view"></component>
    </keep-alive>

    <!-- Array类型（使用`v-bind`） -->
    <keep-alive :include="['home', 'about']">
      <component :is="view"></component>
    </keep-alive>
  </div>
</template>
```

::: danger 注意
include 和 exclude prop 允许组件有条件地缓存：
1. 当使用String类型时，逗号之间不需要留空格；
2. 匹配首先检测组件自身的 name 选项；
:::

当动态组件在&lt;keep-alive&gt;内被切换时，对于缓存的组件来说，只有一开始进入该组件时它的`created`和`mounted`等生命周期函数才执行，但切换到别的组件再次进入该组件时`created`和`mounted`等生命周期函数就不会执行了，因为缓存的组件不会销毁也就不会再次创建一说。可有时确实希望监听到何时进入组件何时离开组件。就可以使用`activated`和`deactivated`这两个生命周期钩子函数来监听。

``` vue
<script>
  export default {
    activated() {
      console.log("about activated");
    },
    deactivated() {
      console.log("about deactivated");
    }
  }
</script>
```

## 异步组件

### webpack的代码分包

通过`npm run build`命令打包项目时，默认的打包情况下，是构建整个组件树的过程。因为组件和组件之间是通过模块化直接依赖的，那么 webpack 在打包时就会将组件模块打包到一起（比如一个app.js文件中）。

例如我们有如下格式目录：

``` js
├─src
|  ├─utils
|  | ├─math.js
|  ├─App.vue
```

在math.js文件中书写sum函数并导出，

``` js
// math.js
export function sum(num1, num2) {
  return num1 + num2;
}
```

在main.js中导入并调用sum函数，当通过`npm run build`打包项目时，因为math.js是自己书写的代码所以会打包到app.js中。  

``` js
// main.js
import {sum} from "./15_异步组件的使用/utils/math";
console.log(sum(20, 30));
```

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/26_webpack默认打包.png')" alt="26_webpack默认打包">

但随着项目的不断庞大，app.js文件的内容过大会造成首屏渲染速度变慢。

所以打包项目时要对代码进行分包，对于一些不需要立即使用的组件，可以单独对它们进行拆分，打包到chunk-hash.js文件中。之后这些chunk-hash.js会在闲暇时或需要时从服务器进行下载，并运行代码显示对应的内容。这样就会优化首屏渲染速度。

webpack针对这种情况是这样做，通过import函数导入模块，后续webpck对其进行打包的时候就会进行分包操作。

``` js
// 通过import函数导入的模块，返回值是一个Promise
import("./15_异步组件的使用/utils/math").then(res => {
  console.log(res.sum(20, 30));
})
```

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/27_webpack的import函数分包操作.png')" alt="webpack的import函数分包操作">

### vue中实现异步组件

应对项目过大，对某些组件希望通过异步的方式进行加载（目前是可以对其进行分包操作），Vue提供了一个函数： `defineAsyncComponent`。

`defineAsyncComponent`函数接受两种类型的参数：
* 工厂函数，该工厂函数需要返回一个 Promise 对象；
* 对象类型，对异步组件进行配置；

工厂函数的写法：

``` vue
<script>
  import { defineAsyncComponent } from "vue";

  const AsyncCategory = defineAsyncComponent(() => import("./AsyncCategory.vue"))
</script>
```

对象类型的写法：

``` vue
<script>
  import { defineAsyncComponent } from "vue";

  import LoadingComponent from "./LoadingComponent.vue";
  import ErrorComponent from "./ErrorComponent.vue";

  const AsyncCategory = {
    // 工厂函数
    loader: () => import("./AsyncCategory.vue"),
    // 加载异步组件过程中显示的组件
    loadingComponent: LoadingComponent,
    // 加载异步组件失败要显示的组件
    errorComponent: ErrorComponent,
    // 在显示 loadingComponent 之前的延迟 | 默认值：200（单位 ms）
    delay: 2000,
    /**
     * error: 错误信息对象，
     * retry: 一个函数，用于指示当 Promise 加载器 reject 时，加载器是否应该重试
     * fail: 一个函数，指示加载程序退出
     * attempts： 允许的最大重试次数
     */
    onError(error, retry, fail, attempts) {
      if(error.message.match(/fetch/) && attempts <= 3) {
        // 请求发生错误时重试，最多可尝试3次
        retry();
      } else {
        // 注意：retry/fail 就像 Promise 中 resolve/reject 一样，必须调用其中的一个才能继续错误处理。
        fail();
      }
    }
  }
</script>
```

### 异步组件和Suspense

::: warning 警告
实验性

当前（2021-11-17）Suspense 是一个实验性的新特性，其 API 可能随时会发生变动。
:::

&lt;suspense&gt;是内置的全局组件，该组件提供两个插槽。它们都只接受一个直接的子节点。如果可以加载到该异步组件就显示default插槽的内容，否则就先显示fallback插槽的内容，等到加载到异步组件后就显示default插槽的内容。

``` vue
<!-- App.vue -->
<template>
  <div>
    <suspense>
      <template #default>
        <async-category></async-category>
      </template>
      <template #fallback>
        <loading-component></loading-component>
      </template>
    </suspense>
  </div>
</template>

<script>
  import LoadingComponent from "./LoadingComponent.vue";
  const AsyncCategory = defineAsyncComponent(() => import("./AsyncCategory.vue"));

  export default {
    components: {
      AsyncCategory,
      LoadingComponent
    }
  }
</script>
```

::: danger 注意
异步组件是做代码分包的，一般是路由分包多一些，如果自己的组件太大了也可以这样来分包。
:::

## 获取元素或者子组件

### $refs

一些情况下，我们想在组件中直接获取到**元素对象**或者**子组件实例**，但在Vue开发中是不推荐进行DOM操作的（通过document.getElementById()或者document.querySelector()等方式），这时就可以给元素或者组件上绑定一个 ref 的 attribute 属性。

``` vue
<!-- App.vue -->
<template>
  <div>
    <h2 ref="title">Hello World</h2>
    <nav-bar ref="navbar"></nav-bar>

    <button @click="btnClick">获取数据</button>
  </div>
</template>

<script>
  import NavBar from "./NavBar.vue";

  export default {
    components: {
      NavBar
    },
    methods: {
      btnClick() {
        // 访问元素
        console.log(this.$refs.title);

        // 访问组件
        console.log(this.$refs.navbar.$el);
        console.log(this.$refs.navbar.title);
        this.$refs.navbar.sayHello();
      }
    }
  }
</script>

<style scoped>

</style>
```

``` vue
<!-- NavBar.vue -->
<template>
  <div>
    <h2>{{title}}</h2>
  </div>
</template>

<script>
  export default {
    data() {
      return {
        title: "NavBar"
      }
    },
    methods: {
      sayHello() {
        console.log("sayHello");
      }
    }
  }
</script>

<style scoped>

</style>
```

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/28_引入元素对象和组件实例.png')" alt="引入元素对象和组件实例">

发现我们有一个结果拿到的是Proxy对象，因为在Vue3中将许多东西都放到Proxy代理中，拿到Proxy中的某些属性或者调用方法时，本质操作的都是组件实例。实际组件实例被Proxy做了一层代理。

### $parent和$root

$parent或$root用于在子组件中访问到其父组件或根组件。

``` vue
<template>
  <div>
    <h2>{{title}}</h2>

    <button @click="getParentAndRoot">获取父组件或根组件</button>
  </div>
</template>

<script>
  export default {
    methods: {
      getParentAndRoot() {
        console.log(this.$parent.title);
        console.log(this.$root.title);
      }
    }
  }
</script>
```

但不建议在子组件中通过$parent或$root拿其组件中的属性进行在该子组件中展示。这样代码的耦合性太强了。真实情况还是使用props传递数据。

::: danger 注意
在Vue3中已经移除了 $children 的属性，所以不可以再使用 $children 拿所有的子组件了。
:::

## 生命周期函数

### 认识生命周期函数

每个组件都会经历从**创建、挂载（挂载到DOM上）、更新、卸载**等一系列的过程。在这个过程中的某一个阶段，用户可能会想要添加一些属于自己的代码逻辑（比如：组件创建完后想发送网络请求，请求一些服务器数据）。所以就想知道组件在哪一个过程，Vue提供了组件的生命周期函数就可以。

生命后期函数本质上是钩子函数，在某些特定的时间会被Vue源码内部进行回调。通过对生命周期函数的回调，就可以知道组件目前在经历什么阶段。那么就可以在该生命周期函数中书写属于自己的代码逻辑。

### 生命周期函数的流程

<img class="medium" :src="$withBase('/frontend/frame/vue3/08_component/29_生命周期函数图示.svg')" alt="29_生命周期函数图示">


## 组件的v-model

前面学习过可以在input中使用v-model来完成双向绑定，其实v-model默认帮助完成两件事情：通过v-bind:value绑定数据和@input的事件监听。

``` vue
<!-- App.vue -->
<template>
  <div>
    <input type="text" v-model="message" /> -->
    <!-- 相当于 -->
    <input type="text" :value="message" @input="message=$event.target.value" />
  </div>
</template>

<script>
  export default {
    data() {
      return {
        message: "Hello World"
      }
    }
  }
</script>
```

Vue也提供了在自定义组件上使用v-model，来同时完成这两个功能。当我们在组件上使用的时候，等价于如下操作：

``` vue
<!-- App.vue -->
<template>
  <div>
    <my-input v-model="message"></my-input>
    <!-- 相当于 -->
    <my-input :model-value="message" @update:model-value="message=$event"></my-input>
  </div>
</template>

<script>
  export default {
    data() {
      return {
        message: "Hello World"
      }
    }
  }
</script>
```

我们发现，和input元素不同的只是属性名称和事件触发的名称不同而已。

那么，为了让my-input组件可以正常工作，这个组件内的&lt;input&gt;必须：
* 将其 value attribute 绑定到一个 modelValue 的 props 上；
* 当 input 事件被触发的时候，将新的值通过自定义的 update:modelValue 事件抛出；

``` vue
<!-- App组件 -->
<template>
  <div>
    <my-input v-model="message"></my-input>

    <h2>{{message}}</h2>
  </div>
</template>

<script>
  import MyInput from "./MyInput.vue";

  export default {
    components: {
      MyInput
    },
    data() {
      return {
        message: "Hello World"
      }
    }
  }
</script>
```

``` vue
<!-- MyInput组件 -->
<template>
  <div>
    <input type="text" :value="modelValue" @input="btnClick" />
  </div>
</template>

<script>
  export default {
    props: {
      modelValue: {
        type: String
      }
    },
    emits: ["update:modelValue"],
    methods: {
      btnClick(event) {
        this.$emit("update:modelValue", event.target.value);
      }
    }
  }
</script>
```

但依然希望在组件内部通过双向绑定的做法去完成，你肯定会想到通过如下方式去完成：

``` vue
<!-- MyInput.vue -->
<template>
  <div>
    <input v-model="modelValue" >
  </div>
</template>

<script>
  export default {
    props: {
      modelValue: {
        type: String
      }
    }
  }
</script>
```

v-model 去绑定 modelValue 是有问题的，外面的 App 组件中的 message 是不改的。这样做不对但也不推荐这样做，原因是：
* 1. 父组件通过 props 传递 modeValue 到子组件，子组件内随便改都不会修改父组件的值；
* 2. 在开发中，不要随便去修改 props 中的值，这是大忌；

在开发中通过绑定v-model这种情况的时候，我们可以使用计算属性的setter和getter来完成。
* getter获取通过`return this.modelValue`，从props中拿到modelValue，相当于:value="value"；
* setter设置触发自定义事件`this.$emit("update:modelValue", newValue)`，input改变就发出自定义事件；

``` vue
<!-- MyInput.vue -->
<template>
  <div>
    <input v-model="value" >
  </div>
</template>

<script>
  export default {
    props: {
      modelValue: {
        type: String
      }
    },
    emits: ["update:modelValue"],
    computed: {
      value: {
        set(newValue) {
          this.$emit("update:modelValue", newValue);
        },
        get() {
          return this.modelValue;
        }
      }
    }
  }
</script>
```

以上是通过v-model在组件上绑定一个属性，当然也可以绑定多个属性。我们知道默认情况下v-model通过v-bind绑定modelValue属性和通过v-on监听update:modelValue事件。如果希望可以绑定更多的值，给v-model添加一个参数，这个参数的名称就是我们绑定的属性名称。

这个 v-model:title 相当于做了两个事情：
* 通过v-bind绑定了title属性；
* 通过v-on监听update:title事件；

``` vue
<!-- App.vue -->
<template>
  <div>
    <my-input1 v-model="message" v-model:title="title"></my-input1>

    <h2>{{message}}</h2>
    <h2>{{title}}</h2>
  </div>
</template>

<script>
  import MyInput1 from "./MyInput1.vue";

  export default {
    components: {
      MyInput1
    },
    data() {
      return {
        message: "Hello World",
        title: "哈哈哈"
      }
    }
  }
</script>
```

``` vue
<!-- MyInput1.vue -->
<template>
  <div>
    <input type="text" v-model="value" />
    <input type="text" v-model="why" />
  </div>
</template>

<script>
  export default {
    props: {
      modelValue: {
        type: String
      },
      title: {
        type: String
      }
    },
    emits: ["update:modelValue", "update:title"],
    computed: {
      value: {
        get() {
          return this.modelValue;
        },
        set(value) {
          this.$emit("update:modelValue", value);
        }
      },
      why: {
        get() {
          return this.title;
        },
        set(newValue) {
          this.$emit("update:title", newValue);
        },
      }
    }
  }
</script>

<style scoped>

</style>
```